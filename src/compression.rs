use crate::errors::*;
use libflate::gzip::Decoder;
use std::borrow::Cow;
use std::io::Read;

pub const GZIP_MAGIC: &[u8] = &[0x1f, 0x8b];
pub const LZMA_MAGIC: &[u8] = &[0xfd, 0x37, 0x7a, 0x58];

pub fn decompress(mut bytes: &[u8]) -> Result<Cow<[u8]>> {
    if bytes.starts_with(GZIP_MAGIC) {
        debug!("Detected gzip compression");
        let mut decoder = Decoder::new(bytes)?;
        let mut buf = Vec::new();
        decoder.read_to_end(&mut buf)?;
        Ok(Cow::Owned(buf))
    } else if bytes.starts_with(LZMA_MAGIC) {
        debug!("Detected lzma compression");
        let mut buf = Vec::new();
        lzma_rs::xz_decompress(&mut bytes, &mut buf)?;
        Ok(Cow::Owned(buf))
    } else {
        debug!("Did not detect any compression, using as tar directly");
        Ok(Cow::Borrowed(bytes))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_decompress_gz() {
        let bytes = [
            0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xcb, 0x48, 0xcd, 0xc9,
            0xc9, 0x57, 0x28, 0xcf, 0x2f, 0xca, 0x49, 0x01, 0x00, 0x85, 0x11, 0x4a, 0x0d, 0x0b,
            0x00, 0x00, 0x00,
        ];
        let txt = decompress(&bytes).unwrap();
        assert_eq!(&*txt, b"hello world");
    }

    #[test]
    fn test_decompress_xz() {
        let bytes = [
            0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x00, 0x00, 0x04, 0xe6, 0xd6, 0xb4, 0x46, 0x04, 0xc0,
            0x0f, 0x0b, 0x21, 0x01, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xb9, 0x3e, 0x01, 0x65, 0x01, 0x00, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77,
            0x6f, 0x72, 0x6c, 0x64, 0x00, 0x00, 0xda, 0x52, 0x23, 0xef, 0xcd, 0x7e, 0x03, 0x53,
            0x00, 0x01, 0x2b, 0x0b, 0xca, 0x91, 0x24, 0xc1, 0x1f, 0xb6, 0xf3, 0x7d, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x04, 0x59, 0x5a,
        ];

        let txt = decompress(&bytes).unwrap();
        assert_eq!(&*txt, b"hello world");
    }
}
